
%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

%\documentclass[twoside,twocolumn]{article}
%\documentclass{article}[11pt]
\documentclass[fleqn]{article}
\usepackage{graphicx}
\usepackage{listings}

\lstset{
  xleftmargin=1em,
  numbers=left,
  firstnumber=1,
  numberfirstline=true
}
\usepackage{xcolor} %custom colours
\usepackage{mdframed} %nice frames

\definecolor{light-gray}{gray}{0.95} %the shade of grey that stack exchange uses

%Put in the main document

\usepackage{blindtext} % Package to generate dummy text throughout this template

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

\usepackage{amsfonts}

\usepackage{amsmath}

\usepackage[english]{babel} % Language hyphenation and typographical rules

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text

\usepackage{enumitem} % Customized lists
\setlist[itemize]{noitemsep} % Make itemize lists more compact

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
\renewcommand\thesubsection{\roman{subsection}} % roman numerals for subsections
\titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\fontsize{10}{10}\bfseries}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{Verifying synchronous distributed algorithms using IVy $\bullet$ Calvin Claus} % Custom header text
\fancyfoot[RO,LE]{\thepage} % Custom footer text

\usepackage{titling} % Customizing the title section

\usepackage{hyperref} % For hyperlinks in the PDF

\lstset{basicstyle=\small}

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\setlength{\droptitle}{-4\baselineskip} % Move the title up

\pretitle{\begin{center}\Huge\bfseries} % Article title formatting
  \posttitle{\end{center}} % Article title closing formatting
\title{Verifying synchronous distributed algorithms using IVy} % Article title
\author{%
  \textsc{Calvin Claus (1429713)}
  \normalsize TU Wien\\ % Your institution
  \normalsize \href{mailto:e1429713@student.tuwien.ac.at}{e1429713@student.tuwien.ac.at} % Your email address
}
\date{\today} % Leave empty to omit a date
\renewcommand{\maketitlehookd}{%
  \begin{abstract}
    \noindent  This paper gives an introduction into IVy and the IVy language, explaining
     the problem it solves, its basic principles and the usual context in which it can be utilized.
     It presents a specification of the \textit{Floodset} algorithm to illustrate by example how
     IVy can be employed by protocol designers to verify consensus algorithms, and the problems one might encouter.
     Finally, the work evaluates on IVy, pointing out strengths and important limitations of automatic verification with the system.
  \end{abstract}
}

%----------------------------------------------------------------------------------------

\begin{document}

% Print the title
\maketitle

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\section{Introduction}

\lettrine[nindent=0em,lines=3]{D}istributed algorithms is a class of algorithms that is designed to run on a set of distributed processors. They solve important problems in distributed systems such as leader election, resource allocation and \textbf{consensus}. Consensus algorithms aim to create agreement among a set of processors. For example, an airplane may posses a redundant set of sensors measuring the same quantity. They must finally agree on a value that is as accurate as possible, while being able to handle failure of a subset of sensors. To establish agreement between sensors a distributed consensus algorithm may be used.  Currently these algorithms are proven by hand. In light of the relevance of distributed algorithms, it is useful to automatise the process of proving their correctness.

  \textit{Automatic verification} takes an algorithm and exhaustively checks if the algorithm satisfies some specification. While this approach is conveniently fully automatic it is not applicable to infinite state systems as their state-space can, by definition, not be exhaustively searched. It is therefore not generally applicable to \textit{parameterized} distributed (consensus) algorithms, which take the number of processors communicating as a parameter.\cite{limits}

  On the other hand, \textit{deductive verification} takes an algorithm and some invariant. It proves the invariant is inductive with respect to the algorithm. If the invariant implies the correctness of the algorithm, the algorithm has been proven correct. This process does not exhaustively search all possible states and is therefore applicable to distributed (consensus) algorithms, however it relies on the user to annotate invariants.

  Ivy is tailored to simplify deductive verification of parameterized distributed algorithms. There are a variety of systems currently implementing the deductive verification process. IVy makes use of the same underlaying principle, but it aims to increase user friendliness of the verification process.  IVy's hypothesis is that ``automated methods are difficult to apply in practice not primarily because they are unreliable, but because they are opaque''; meaning that they fail in ways inexplicable to the user. In light of this, the IVy system was designed to display proof-failure comprehensively to the human user, making the root cause of errors more visible. \cite[ p.1]{ivy}

  This paper will give an introduction to the IVy system and its language. It will explain the paradigms underlying the automatic verification tool, its language and the context in which it may be employed.  \textit{Floodset}, a simple distributed algorithm, will be explained and used as an example to illustrate the strengths and limitations of the IVy system in verifying algorithms operating in a network. First \textit{Floodset} will be manually proven and then deductively verified.  The goal of this work is to give readers a foundational understanding of IVy and a head start in verifying their own distributed algorithms.

  This paper does not aim to be a comprehensive documentation or quantitatively compare IVy's effectiveness to other verification tools.

\section{IVy}
IVy is a system designed to verify correctness of infinite-sate systems using the aforementioned deductive approach. It takes as input a specification of an algorithm operating on system-state  and a set of invariants. It proves the inductiveness of the invariants in respect to the algorithm, or displays a counterexample to induction. If the set of invariants entails the desired properties of the algorithm, and Ivy proved induction, then it was proven that the algorithm is \textit{correct}.

In Ivy, the entity ``calling'' the algorithm in different state configurations is called the ``environment''. The environment conceptually represents the final users of the algorithm. An algorithm or protocol is \textit{correct} or \textit{safe} if it cannot be called by the environment in a state configuration that causes some pre-defined properties (assertions, invariants) to be violated. IVy supports verification of systems that have multiple methods (\textit{actions}) exported to the environment. For example to verify servers that specify connection and disconnection algorithms. This can be thought of as proving inductiveness of two independent algorithms with respect to the same invariants and system-state.

\subsection{How IVy is used}

A common algorithm verification workflow, which incorporates IVy for verification, is a two step process:

\begin{enumerate}
  \item encoding/specification of algorithm in IVy language
  \item correctness and safety verification
\end{enumerate}

\subsubsection{Step 1 - encoding in IVy language}
Step 1 requires the user to understand the Ivy language. This language is a specification language tailored to describe state changes in a system. Ivy language code is inherently different from procedural languages, as it serves a different purpose and its logic is never executed. The Ivy documentation itself calls the language features "unusual" \cite{refLanguageDoc} so a user may need considerable effort to understand how to best use its tools.

Using their understanding of the Ivy language users have to encode their algorithm in it. However, distributed algorithms rarely exist in a vacuum. Algorithms such as \textit{Floodset} are defined within a \textit{system context} or \textit{framework} \cite{refNancy}, and make no sense without first defining this \textit{framework}. Thus users have to encode their algorithm together with the \textit{framework} in which the algorithm was designed to execute. This may include things such as network topology, the amount of processors that may fail, how and when processors fail, details about message sending, etc.

The encoding process therefore not only requires a clear understanding of how the algorithm works, but also of all assumptions about the context in which it executes. This process is therefore fully creative, requires deep understanding of the system as a whole, and will most likely not allow a mindless one-to-one translation from a procedural algorithm.

\subsubsection{Step 2 - verification}
The verification happens in step 2. The goal is to specify an inductive invariant that describes the properties to be proven about the algorithm. \textit{Inductive} is an important
keyword here. An invariant is \textit{inductive} iff the following three properties are satisfied \cite{invariants}:
\begin{enumerate}
  \item initiation: the invariant is true in all legal initial states
  \item safety: for any program state that satisfies the invariant - regardless of whether this state is reachable - no \textit{exported} action can cause an assertion failure starting in that state
  \item consecution: for any program state that satisfies the invariant - regardless of whether this state is reachable - after executing any \textit{exported} action, the invariant remains satisfied
\end{enumerate}
To a user without any experience in automatic verification, \textit{inductive} invariants are a difficult concept.
IVy does not consider the reachability of a system state.  As long as the state is in compliance with the invariants it is assumed to be reachable.
Thus, when IVy generates counterexamples that are clearly not reachable, e.g. negative values for counters that are set to zero at initialization, the solution is to specify an invariant that excludes these state, e.g. $invariant\ counter \geq 0$.

When we say that the specified invariants need to be \textit{inductive} we mean the conjunction of the set of invariants specified throughout the entire program, not each invariant individually.

The name "IVy" stems from "interactively verifying", which highlights the key differentiator of IVy to Coq or Dafny.\cite{ivy}
IVy actively supports the user in the search for an inductive invariant by graphically displaying a concrete minimal counterexample to induction (CTI).
The user can then generalize from the counterexample to strengthen the invariants. This \textit{counterexample} $\rightarrow$ \textit{strengthened invariant} $\rightarrow$ \textit{counterexample} process continues
until an inductive invariant is found and the correctness of the algorithm is proven.

\subsection{The IVy language}
The IVy language is a core part of the IVy system. It is the language through which the behaviour of the algorithm to be verified is defined.
This section presents a selection of core language features that should help the reader understand the paradigm of modelling in IVy, as well as lay the necessary foundation to understand
the rest of the work presented in this paper. This section oversimplifies and does not give an exhaustive documentation, which is given in \cite{refLanguageDoc}.

\subsubsection{Types and declarations}
In IVy one mainly uses \textit{uninterpreted} types. \textit{Uninterpreted} means that the type is an arbitrary set of values with at least one element.
The cardinality of this set is \textit{parameterized}, meaning IVy proves correctness for an arbitrary amount of values of an \textit{uninterpreted} type.
The number of values of a type that are generated to construct a counter example to induction (CTI) is entirely up to IVy. No instances of these types are manually instantiated.
This is useful for declaring types such as \textit{node}, \textit{process} or \textit{value} in a system.

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
type node
\end{lstlisting}
\end{mdframed}

\noindent To relate instances of types to each other we can declare functions.

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
type node
type value
function value(N:node) -> value
\end{lstlisting}
\end{mdframed}

\noindent A function that maps to bool can be declared as a relation, so

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
function message_received(RECEIVER:node, SENDER:node) -> bool
\end{lstlisting}
\end{mdframed}

\noindent is the same as

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
relation message_received(RECEIVER:node, SENDER:node)
\end{lstlisting}
\end{mdframed}

\subsubsection{Actions}
The syntax to define an action, that is callable from within another action, or from the environment when \textit{exported} is:

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}

action exported_action(x:node) = {
  call internal_action;
}
export exported_action

action  internal_action = {
  . . .
}
\end{lstlisting}
\end{mdframed}

\subsubsection{Assignments}

To assign values to relations, functions or variables $:=$ is used.
\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
action our_action(x:node) = {
  failed(x) := true;
}
\end{lstlisting}
\end{mdframed}
Lower case tokens refer to an individual value. In the code above \textit{x} refers to the specific instance of type \textit{node} that has been passed to \textit{our\_action}. The value of the relation \textit{failed(x)} is changed to \textit{true} only for that instance of \textit{node}.

In Ivy one often wants to specify system-wide state-changes. For this reason Ivy allows iterator-free assignments involving all instances of a type. To make such an assignment one can use placeholders that are denoted by uppercase tokens. For example, to set all nodes without an incoming message to \textit{failed}:

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
failed(X:node) := ~incoming_message(X:node);
\end{lstlisting}
\end{mdframed}

\noindent This is conceptually the same as the following pseudo-code:

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
# Pseudocode only:
foreach x of type node {
  failed(x) := ~incoming_message(x);
}
\end{lstlisting}
\end{mdframed}

The language only supports assignments where each placeholder that appears on the right hand side of an assignment is also on the left hand side.


\subsubsection{Non deterministic choice}
To non-deterministically assign to a variable, relation or function ``*'' is used.
For example, this line non-deterministically chooses a number of nodes to have failed.

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
failed(X) := *;
\end{lstlisting}
\end{mdframed}

\subsubsection{Assume, require and ensure}
To specify safety conditions in an action we can use \textit{require} and \textit{ensure}.
They both act like a traditional assert: they do not allow control to pass if they evaluate to false.
However, they are different semantically: \textit{require} assigns blame to the actions caller, while \textit{ensure}
is a condition that the action itself must guarantee. \textit{Require} is especially relevant to restrict
the environment in the way it can call an action.

\textit{Assume} is used to exclude the possibility of something happening.  This is mostly useful in combination with non-deterministic assignments that one wants to restrict. The following action chooses a random node to assign to \textit{y}, but will not allow control to pass if the chosen node has failed. Therefore the actions will choose a random non-failed node to send a message to x.  If there is no node that hasn't failed, this action cannot terminate.

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
action random_node_sends_message_to(x:node) = {
  y := *;
  assume ~failed(y);
  send(x, y);
}
\end{lstlisting}
\end{mdframed}

\textit{Assume} simplifies modelling in some situations, as it can easily eliminate impossible behaviour. However,
it is risky to use \textit{assume} for the same reason: one might dismiss a valid counterexample to the specification
by assuming it cannot happen. To give an extreme example, putting $assume\ false$ at the beginning of an exported action will cause all of Ivy's checks for induction to come out positive.


\subsubsection{Invariants}
To specify the properties we want to prove about our algorithm we encode them in special assertions called \textit{invariants}:

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
invariant system.rounds >= 0
invariant system.rounds < 100
\end{lstlisting}
\end{mdframed}
The conjunction of these must hold at all times when an action is not executing, thus they have to be initially true and each of
the \textit{exported} actions must preserve them. However, an invariant is not guaranteed to hold when an action calls another action.

\subsection{Decidability}
First order logic is undecidable in general, but still many interesting properties can be expressed in a subset of first oder logic called the ``decidable fragment''. Ivy's documentation defines this subset of first-order formulas. \cite{decid}

For example, Ivy only allows stratified functions. Meaning that a graph, with every type being a node and every function mapping from type $A$ to type $B$ be an edge from $A$ to $B$, has to be cycle free. Thus, there cannot be a function from $X \rightarrow Y$ and from $Y \rightarrow X$ in the same specification.

A detailed discussion about decidability lies outside of the scope of this work and is well documented in \cite{decide}.

While a complete understanding of decidability in Ivy is advantageous, to use Ivy successfully it is not strictly necessary. This is because Ivy assists the user and tries to automatically determine if formulas lie outside of the decidable fragment. It warns users about specifications that it estimates are undecidable.  It must be noted that IVy's check is conservative as ``fully unfolding all of the definitions could be exponential''. Ivy may report specifications as undecidable which are in fact decidable. For this reason IVy allows the check to be deactivated. \cite{decid}


\section{Distributed Consensus Algorithms with stopping failures}

The algorithm that was implemented in IVy as part of this work is called \textit{Floodset} and was taken out of Lynch's work ``Distributed Algorithms'' \cite{refNancy}.
\textit{Floodset} is a consensus algorithm for synchronous networks with failing processes.
To understand \textit{Floodset}, one needs to first understand the aforementioned \textit{framework}/\textit{system} within which this algorithm operates, which is also defined in \cite{refNancy}.

\subsection{Framework - Synchronous Network Systems}

The network of processes is represented as a directed graph $G=(V,E)$. Where $n$ is $|V|$, the number of nodes in the network. Each node represents a process in the network.
The communication paths between nodes are represented by directed edges in the graph.
$outnbrs_i$ is the set of nodes to which an edge from node $i$ exists.
$innbrs_i$ is the set of nodes from which an edge to node $i$ exists.
$M$ denotes the message alphabet, meaning that elements of $M$ can be used to construct messages (vectors of elements of $M$) from nodes to other nodes.
There are a number of components associated with each node:
\begin{itemize}
    \item $states_i$, a set of states (can be infinite)
    \item $start_i$, a nonempty subset of $states_i$
    \item $msgs_i$, a message generation function that maps $states_i \times outnbrs_i$ to elements of $M \cup \{null\}$
    \item $trans_i$, a state transition function that maps $states_i \times vectors\ of\ M$ index by $innbrs_i$ to $states_i$
\end{itemize}
Thus, a node is always in some state in $states_i$. Importantly, the set of states is not necessarily finite, meaning that unbounded data structures like arrays can be modeled in the system.
Each node defines a message generation function $msgs_i$, that uses the current state to return a message for each out neighbour. Similarly, each node has a state transition function $trans_i$, that is used to determine
from the current state and all incoming messages the next state the node will transition to.

The edges in the graph are called channels and can hold at most one message at a time or $null$ to denote an empty channel.
The system of nodes operates in steps. It begins with all nodes in an arbitrarily chosen start state from $start_i$ and all channels empty.
The processes then repeatedly perform the following two steps \textit{synchronously}:
\begin{itemize}
  \item Apply the message generation function inputting the current state and one of the outgoing neighbours. Put these message in the channel to the chosen outgoing neighbour. Do this for each outgoing neighbour.
  \item Apply the state transition function to the current state and the array of incoming messages. Transition the node to the returned state. Remove all messages from the channels.
\end{itemize}
\textit{Synchronously} in this case means, that all nodes wait for each other to finish Step 1 before executing Step 2 and vice versa.
The combinations of these two steps is a \textit{round}.

\subsection{Stopping failures}
The system presented in Lynch's work \cite{refNancy} is capable of modelling failure in a variety of ways.
This work makes use of stopping failure only. This kind of failure occurs when a process stops in the middle of its execution. With regards to the presented \textit{framework} this
is modeled as a process failing before or after performing some instance of Step 1 or Step 2. Additionally, a process may also stop in the middle of performing Step 1. This allows
the interesting situation in which a process has communicated its messages to some, but not all processes. It is important to note, that processes are not thought of performing
the message generation operation sequentially. Instead, we say that the order in which messages are put in the channels is non-deterministic. This clarification, allows a failing process
to send its messages to an arbitrary subset of its outgoing neighbours only. A process that has failed cannot restart at a later point in time.


\subsection{Floodset}
The problem \textit{Floodset} solves is as follows: An arbitrary number of nodes (or processes) $n > 0$, in a complete, undirected network with fully reliable channels, start with individual inputs from a value set $V$ and a default value $v_0 \in V$ that is equal for all nodes. Processes should communicate with each other through several \textit{rounds} to eventually decide on a single value $v_d \in V$. Nodes may fail according to the \textit{stopping failure} model. The total number of failing processes is bounded by a constant $f < n$. The entire network knows the value of $f$.  The network should satisfy the following conditions:

\begin{itemize}
  \item \textbf{Agreement}: No two processes decide on different values.
  \item \textbf{Validity}: If all processes start with the same initial value $v \in V$, then $v$ is the only possible decision value
  \item \textbf{Termination}: All nonfaulty processes eventually decide.
\end{itemize}

We refer to these condition as ``correctness conditions'', as we say the algorithm is ``correct'' if we can prove it satisfies these conditions.  \textit{Floodset} solves the described problem by defining $msgs$ and $trans$ functions for nodes in the network such that the conditions are satisfied.

\textbf{Informal explanation of \textit{Floodset}}: Processes hold a set $W$ as one of their state components which holds the subset of values of $V$ that the process has seen. Every node's initial $W$ holds only its initial value.  In Step 1 of every round nodes broadcast their $W$. In Step 2 all $v \in V$ that \textit{(a)} are sent to a process and \textit{(b)} the process does not yet hold in its $W$ are added to its $W$. In the $f+1$th round a node decides: If $W$ is a singleton set then it decides on the unique element of $W$, otherwise it decides on the default value $v_0$.  \textit{Deciding} is modeled by nodes setting a special \textit{decision} state component to a value in $V$.

\textbf{Formal definition of \textit{Floodset}}:
\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\noindent $states_i$:
\begin{gather*}
  rounds   \in  \mathbb{N}, \ \mathrm{initially} \ 0 \\
  decision  \in  V \cup \{ unknown \}, \ \mathrm{initially} \ unknown \\
  W \subseteq V, \ \mathrm{initially \ the\  singleton\  set\  consisting\  of\  i's\  initial\  value}
\end{gather*}
\end{mdframed}

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\noindent $msgs_i$:
\begin{gather*}
  if\ rounds \le f\ \mathrm{send}\ W\ \mathrm{to\ all\ other\ processes}
\end{gather*}
\end{mdframed}


\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\noindent $trans_i$:
\begin{gather*}
  rounds\ :=\ rounds+1\\
  \mathrm{let}\ X_j\ \mathrm{be\ the\ message\ from\ j,\ for\ each\ j\ from\ which\ a\ message\ arrives}\\
  W\ :=\ W \cup \bigcup_{j} X_j\\
  \mathrm{if}\ rounds = f+1\ \mathrm{then}\\
  \ \ \   \mathrm{if}\ |W| = 0\ \mathrm{then}\ decision := v,\ \mathrm{where}\ W = {v}\\
  \ \ \   \mathrm{else}\ decision := v_0
\end{gather*}
\end{mdframed}

\noindent What follows is a proof of the correctness of the \textit{Floodset} algorithm to illustrate the principles behind it. It has already been proven correct in \cite{refNancy}. This work presents a slightly varied approach to the proofs of \cite{refNancy} founded on the same general proof ideas.\\
\\
\noindent Let $W_i(j)$ denote the value of $W$ for node $i$ in round $j$. The following Lemmas apply:\\

\noindent \textbf{Lemma 1}:\\
If no process fails during a particular round $r,\ 1 \le r \le f + 1$, then $W_i(r) = W_j(r)$ for all $i$ and $j$ that did not fail after $r$ rounds.\\
\textbf{Proof}:\\
\textit{Indirect}: If there exists a value $v \in V$ that is in $W_i(r)$ but not in $W_j(r)$ after round $r$, in which no process failed, that implies, that some node $k$ sent a value to $i$ that it did not send to $j$, or $i$ failed to send a member of $W_i(r-1)$. Since all nodes broadcast their $W$, this is only possible if node $k$ or $i$ failed to send at least one message. But since no processes failed, each process must have shared their $W$ with every other process. \textit{Contradiction}. \\

\noindent \textbf{Lemma 2}:\\
Suppose that $W_i(r) = W_j(r)$ for all $i$ and $j$ that did not fail after $r$ rounds. Then for any round $r',\ r \le r' ≤ f + 1$, the same holds, that is, $W_i(r’) = W_j(r’)$ for all $i$ and $j$ that did not fail after $r’$ rounds.\\
\textbf{Proof}:\\
Since all active nodes have equal $W$s after $r$ rounds, there exists no $v \in V$ that is in some $W_i(r),\ \neg failed(i)$, that is not in every other $W_j(r), \neg failed(j)$.
Since nodes will only send their $W$s, this implies that no node can send a message in some future round $r'$ that contains a value $v$ that some node does not have in its $W$, thus $W_i(r’) = W_j(r’)$, $\neg failed(i) \land \neg failed(j)$.\\

\noindent \textbf{Lemma 3}:\\
After $f+1$ rounds there has been a round $r'$ in which no process failed\\
\textbf{Proof}:\\
\textit{Indirect:} If a process failed in all of $f+1$ rounds at least on process must have failed in all of the $f+1$ rounds. This implies
that at least $f+1$ processes failed. Only $f$ processes can fail. \textit{Contradiction}.\\


\noindent \textbf{Lemma 4}:\\
If processes $i$ and $j$ are both active after $f+1$ rounds, then $W_i = W_j$ at the end of round $f + 1$.\\
\textbf{Proof}:\\
It follows from \textit{Lemma 3}, that after $f+1$ rounds at least one round, $r'$, in which no process failed, occurred. From \textit{Lemma 1} we therefore derive that $W_i(r') = W_j(r')$ for all active $i,\ j$.
From \textit{Lemma 2} it follows that $W_i(f+1) = W_j(f+1)$. \textit{Q.e.d}.\\

\noindent The Lemmas allow proving the theorem:\\
\noindent \textbf{Thorem}:\\
\textit{Floodset} satisfies the correctness conditions.\\
\textbf{Agreement}:\\
From \textit{Lemma 4} we know what $W_i = W_j$ after $f+1$ rounds. Since all decision conditions are the same and only depend on $W$, agreement is satisfied.\\
\textbf{Validity}:\\
If all processes start with the same initial value $v \in V$, then there exists no value $v', v \neq v'$, that is part of any $W$. Thus, from $W_i(f+1) = W_j(f+1)$, $\neg failed(i) \land \neg failed(j)$, and $W_i(f+1) = \{v\}$ it follows
that every active node decides $v$.\\
\textbf{Termination}:\\
Trivially, nodes decide after $f+1$ rounds.\\

This work now presents a way to translate Lynch's \textit{framework} and the \textit{Floodset} algorithm to a specification in the IVy language.

\section{Specification}
To summarize: we have a parameterized system with $n$ process and $f$ number of faults. We want to show \textit{Floodset} is correct regardless of the parameters.
It is trivial to verify for a small number of $n,\ f$, but the question is ``does \textit{Floodset} work for any assignment of $n,\ f,\ n < f$''.
To answer this question the algorithm was encoded in the IVy language and then inductive invariants were constructed to prove correctness.


\subsection{Modeling strategy}

This section walks through the specification step by step. It illustrates the paradigms relevant to verification in IVy and presents the challenges that the author came across while specifying in IVy, and how they were overcome. The complete code, together with setup instructions of a Docker container, can be found here \cite{github}.

\subsubsection{Modularity}
When verifying an algorithm like \textit{Floodset} in IVy, an algorithm designer would prefer to translate their original algorithm to the IVy language in as close to a one-to-one fashion as possible. However, this is not quite convenient for \textit{Floodset} and the \textit{framework} it operates in.
To separate system logic and node logic one would have to rely heavily on iterations. E.g. for \textit{Step 1} the system would iterate over all nodes and let each node take care of sending its own message.

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
action round = {
  var iter := node.t.iter.create(0);
  while ~iter.is_end
  {
    call send_messages(iter.val)
    iter := iter.next;
  }
  . . .
}
action send_messages(n:node.t) = {
  node.message(n,V) := node.w(n,V);
  node.incomming_message(O,n) := true;
}

export round
\end{lstlisting}
\end{mdframed}

\noindent However, the code above does not actually execute an iteration over all nodes as one would expect. Looking at an IVy trace we see what really happens:

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
. . .
line 3: message := *;
line 3: incomming_message := *;
. . .
\end{lstlisting}
\end{mdframed}

IVy non-deterministically assigns to all relations involved in the loop, instead of actually executing the loop.  This is because proving correctness of loops can only be done through inductive loop invariants specified by a human. IVy therefore allows specifying invariants together with a loop.
\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
  while ~iter.is_end
  invariant node.message(N,V) = node.w(N,V)
  invariant N <= iter.val -> incomming_message(O,N)
  {
    . . .
  }
\end{lstlisting}
\end{mdframed}

These invariants must hold before the loop and after every iteration. The following is a trace of the execution of the loop with the specified invariants. First, they are asserted, then the relations are set to non-deterministic values, and finally an assume is used to restrict control to relation assignments that fulfil the invariants.

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
assert message(N,V) = w(N,V)
assert N:t <= t.iter.val(loc:iter) -> incomming_message(O,N)
incomming_message := *
message := *
assume message(N,V) = w(N,V)
assume N:t <= t.iter.val(loc:iter) -> incomming_message(O,N)
\end{lstlisting}
\end{mdframed}

As a result of this architecture, the program logic has to be specified twice: once in the form of invariants and another time in the actual loop. Such a program therefore has two possible origins for any error: a fault in the algorithm or an inadequate invariant. This structure also increases the difficulty of debugging, because IVy only shows unhelpful $assert$, $assume$ and  non-determinsitic assignments ($:= *$) in its traces, rather than execution of the actual lines in the $send\_messages$ function.

This approach may still be considered viable for the simple \textit{Step 1}, but for the more complex \textit{Step 2} and the failure simulation logic, the author has found that the duplication of logic and the decreased debugging efficiency makes the increased modularity achieved through iterations not worth the mental and maintenance effort that the loop invariants bring with them.

For this reason the following specification of \textit{Floodset} uses a non-modular structure where single lines predominately alter the state of the system as a whole.


\subsubsection{Cardinality relationships}
There is no cardinality operator in IVy. In set notation we would write something like $|\{n|node(n) \land failed(n)\}|$ to count the number of failed nodes in a system. When programming in a procedural language one would use a loop for this task but, as has been explained in the previous section, loops are somewhat problematic in IVy. The author couldn't find a way to specify an inductive loop invariant for a loop counting the number of failed nodes without a cardinality operator at hand. This means that alternative encodings for the assumption $f<n$ and the \textit{decision condition} ($if\ rounds = f+1$) must be found.

The assumption $f<n$, ``number of failed nodes is bounded to an amount smaller than the number of total nodes'', can alternatively be expressed via $\exists n\ \neg failed(N)$. This is because the existence of a functioning node implies that the number of failed nodes $f$ is smaller than $n$.

To figure out how to alternatively encode the \textit{decision condition} deep understanding of the algorithm is necessary. One must realise that $rounds = f+1$ entails that a ``clean round'' occurred (see \textit{Lemma 3}). Where ``clean round'' describes ``a round in which no node failed''. The processes are ready to decide after a clean round has occurred. They can decide either immediately, or an arbitrary number of rounds after the clean round. This can be modeled with non-determinism:

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
clean_round_occured := (clean_round_occured |
                        (forall N . ~node.failed_during_round(N)));
if clean_round_occured {
  decision_round := *;
};
\end{lstlisting}
\end{mdframed}

\noindent And an invariant that describes the properties of a clean round, which effectively is \textit{Lemma 1}:

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
# lemma 1:
invariant system.clean_round_occured ->
            ((~node.failed(A) & ~node.failed(B)) ->
              (node.w(A, V) = node.w(B, V)))
\end{lstlisting}
\end{mdframed}

\noindent The (other) chosen invariants will be explained in detail later on in this paper.

\subsection{Types, functions, relations}
First the types, functions, relations and individual variables that are used throughout the program are presented. They are annotated with comments explaining their purpose.  Their meaning will become more clear as the code is presented in the following paragraphs.

\begin{mdframed}[backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
type node
type value
object node = {

#graph/system
  # stores the initial value of each X
  function val(X:node) : value

  # stores the default value of the network
  individual def : value

  # stores the default value that each node stores independently
  function default(X: node) : value

  # failed(a) is true if node a failed
  relation failed(A:node)

#state
  # w(n, v) denotes whether n's w contains value v
  relation w(SELF:node, V:value)

  # decision(n, v) denotes whether n has decided on v
  relation decision(SELF:node, VALUE:value)

#communication
  # message(n,v) denotes whether v is broadcast by n
  relation message(N:node, V:value)

  # incomming_message(n,o) denotes whether node n received a message
  # from node o
  relation incomming_message(SELF:node, OTHER:node)

# internal helpers
  # true if a node had already failed before this round
  relation failed_before_round(A:node)

  # true if a node failed during this round
  relation failed_during_round(A:node)

  # true if a node has a single value in w
  relation has_single_value(N:node)

  # helper to simulate non-determinstic message sending
  relation incomming_message_failing(SELF:node, OTHER:node)


}

object system = {
  # true if current round is decision round
  individual decision_round:bool

  # true if a clean round occured in the past, or the current round
  individual clean_round_occured:bool
}
\end{lstlisting}
\end{mdframed}

\subsection{Initialisation}

First, we describe the initial system state in a special \textit{after init} action. When
proving correctness, IVy requires the initialisation to entail the invariants. All relations and functions
that are not assigned are set non-deterministically by the environment. E.g. $node.val(N)$ is
treated as a parameter the environment sets.

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
after init {
  def := *;
  default(N) := def;
  w(N, V) := V=node.val(N);
  incomming_message(A, B) := false;
  decision(N, V) := false;
  clean_round_occured := false;
  decision_round := false;
  node.failed_before_round(N) := false;
  node.failed(N) := false;
  node.has_single_value(N) := false;
}
\end{lstlisting}
\end{mdframed}

\subsection{Rounds}

\noindent A round in the specification is defined as follows:
\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
action round = {
  require ~node.decision(N,V) & ~decision_round;
  node.failed_before_round(N) := node.failed(N);
  call step1;
  call simulate_failure;
  clean_round_occured := (clean_round_occured |
                          (forall N . ~node.failed_during_round(N)));
  if clean_round_occured {
    decision_round := *;
  };
  call step2;
}
export round;
\end{lstlisting}
\end{mdframed}

\noindent \textit{round} is the only exported action. It specifies the basic structure of Lynch's \textit{framework}.
\noindent Line 2 makes it illegal for the environment to call \textit{round} if decisions already occurred.
\noindent Line 3 does some bookkeeping.
\textit{call step1} models the communication step. \textit{simulate\_failure} simulates failure before, during
and after \textit{step1}. After \textit{decision\_round} is set, \textit{call step2} is executed to model the state transition of the nodes.


\subsection{Step 1 - Message sending}
The contents of a node's message is modeled via the relation $message(N:node,V:value)$. Where
$message(1,0) = true; message(1,1) = true;$ means node $1$ includes in its message the values $0$ and $1$.
Since a node sends the same message to all nodes, for any given round, we don't need to include the
recipient in the relation.

The actual delivery of a message is modeled via the $incomming\_message(RECIPIENT:node,SENDER:node)$ relation. Where $incoming\_message(0,1) = true; incoming\_message(0,2) = true;$ means that node $0$ receives the messages from node $1$ and node $2$.

These relations allow us to use IVy's assignments to easily model \textit{Step 1} in a round of \textit{Floodset}.
Line 2 assigns for all nodes $A$ and values $V$ to $message(A,V)$ the boolean value of $node.w(A,V) \land \neg failed(A)$. In other words, every node that hasn't failed prepares a message with all values in its $w$. Line 3 states that all nodes that haven't failed send messages to all other nodes.

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
action step1 = {
  node.message(A,V) := node.w(A,V) & ~node.failed(A);
  node.incomming_message(O,A) := ~node.failed(A);
}
\end{lstlisting}
\end{mdframed}

\subsection{Step 2 - State transition}

Line 2 in the \textit{step2} action adds to $w$ of node $N$ all values $V$ for which a node $J$ exists that has sent a message to $N$ that contains $J$.
The conditional statement in Line 4 corresponds to the \textit{decision condition} ($if\ rounds = f+1$) in the original algorithm. Nodes with a single value in $w$ decide on that value, otherwise
they decide on the default value.
Finally, for good measure, $incomming\_message$ and $message$ are reset, but this is not necessary for the proof.

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
action step2 = {
  node.w(N,V) := (node.w(N,V) |
                 (~node.failed(N) &
                  exists J . (node.incomming_message(N,J) &
                               node.message(J,V))));

  if decision_round {

    node.has_single_value(N) :=
      (exists J . node.w(N,J)) &
      (forall V,O . O=V | (node.w(N,V) -> ~node.w(N,O)));

    node.decision(N,K) :=
      node.has_single_value(N) & node.w(N,K) & ~node.failed(N);

    node.decision(N,node.default(N)) :=
      (~node.has_single_value(N) | node.decision(N,node.default(N)))
      & ~node.failed(N);

  };

  node.incomming_message(A,B) := false;
  node.message(A,V) := false;
}
\end{lstlisting}
\end{mdframed}

\subsection{Failure simulation}


This section shows how the stopping failure model described by Lynch \cite{refNancy} and explained in \textit{section III ii.} was modeled in Ivy.

To recap, a process may fail before or after performing some instance of Step 1 or Step 2 as well as in the middle of performing Step 1.  The presented code for actions \textit{step1} and \textit{step2} already correctly considers the behaviour of nodes that failed before the actions. E.g. \textit{step1} only allows nodes that have not failed to send messages.
\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
. . .
node.incomming_message(O,A) := ~node.failed(A);
. . .
\end{lstlisting}
\end{mdframed}

\subsubsection{Failure before and after rounds}

\noindent Modeling stopping failure before or after any of the steps could therefore be modeled by correctly setting $failed(N)$. Adding the following lines before and after \textit{step1} would do the trick:

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
node.failing_now(N) := *;
assume node.failing_now(N) -> ~node.failed(N);
node.failed_during_round(N) :=
  (node.failed_now(N) | node.failed_during_round(N))
node.failed(N) := (node.failed(N) | node.failed_during_round(N));
assume exists N . ~node.failed(N);
\end{lstlisting}
\end{mdframed}

\noindent This snippet is presented only to convey some intuition about the final modeling decision and is not used in the final specification

Line 1 non-deterministically chooses nodes to fail. The \textit{assume} in line 2 excludes all
cases where a node that already failed was chosen to fail again, as a node can only fail once. Line 3 keeps track of the nodes that failed during the current round to enable \textit{clean\_round\_occured} to be set appropriately later. Line 5 adds the newly failed nodes to the set of failed nodes. Line 6 disallows the possibility that all nodes are chosen to fail and therefore enforces $f < n$.

\subsubsection{Failure during rounds}

However, this specification omits the possibility of node failure during message sending. Step 1 is modeled using statements that alter the system state as a whole. Expressing non-deterministic failure of individual nodes within these statements is inconvenient. The author therefore decided to simulate the behaviour of a node that failed during message sending in a separate piece of code independent of the logic in \textit{step1}. Consider the following snippet.

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
node.incomming_message_failing(N,M) := *;
node.incomming_message(N,M) :=
  (node.failed_during_round(M) &
    node.incomming_message_failing(N,M)) |
  (~node.failed_during_round(M) &
    node.incomming_message(N,M));
\end{lstlisting}
\end{mdframed}

Line 1 prepares for each node $M$ a non-deterministically chosen set of nodes that it sends a message to. This set is represented by the relation \textit{incomming\_message\_failing}. This relation can be thought of as the set of nodes $M$ will send a message to if $M$ fails.
Line 2 updates the \textit{incomming\_message} relation. If node $M$ failed during this round, the set of nodes
 $M$ sends messages to is changed to the values of \textit{incomming\_message\_failing}, otherwise it remains the same. It is important to point out that this approach correctly simulates the fact that nodes are not thought of as sending messages sequentially but in non-deterministic order. The specification makes no assumptions about an order of message sending. Furthermore, for fixed $m$, \textit{incomming\_message\_failing(N,m)} may still be $true$ for all N. The specification therefore includes the possibility of a node failing after it sent all its messages successfully.

\subsubsection{Combination of the two}
Combining the two principles in a single action gives the following \textit{simulate\_failure} action. It is designed to be called once per round between \textit{step1} and \textit{step2}. It simulates failure before, during and after \textit{step1}. As failure before \textit{step2} is the same as failure after \textit{step1} and failure after \textit{step2} is equivalent to failure before \textit{step1} in the following round, it satisfies all criteria of Lynch's \cite{refNancy} stopping failure model.

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
  action simulate_failure = {
    node.failed_during_round(N) := *;
    assume node.failed_during_round(N) -> ~node.failed(N);
    node.failed(N) := (node.failed(N) | node.failed_during_round(N));
    assume exists N . ~node.failed(N);

    node.incomming_message_failing(N,M) := *;
    node.incomming_message(N,M) :=
      (node.failed_during_round(M) &
        node.incomming_message_failing(N,M)) |
      (~node.failed_during_round(M) &
        node.incomming_message(N,M));

  }
\end{lstlisting}
\end{mdframed}

Lines 2 to 5 resemble the snippet of section \textit{vii.1}. In line 2 we choose a random number of nodes to fail. The \textit{assume} in line 3 then excludes all cases where a node that already failed was chosen to fail again. Line 4 adds the newly failed nodes to the set of failed nodes. Line 5 enforces $f < n$. Since this action is only called once per round we do not need an extra relation \textit{failing\_now} presented in \textit{vii.1}.

Line 7 to 12 is equivalent to the snippet of \textit{vii.2} and simulates the message sending behaviour of failing nodes.


\section{Verification}

Now that the system has been modeled, the next step of verifying correctness with IVy is specifying inductive invariants. The simplest invariants to come up with are those, that describe the correctness of the algorithm at hand. In our case, the correctness is described by the \textit{correctness conditions} in \textit{iii}. These are \textit{agreement}, \textit{validity} and \textit{termination}.

\subsection{Agreement}
\textit{Agreement} states that no two correct process decide on different values. It can be described as follows.

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
invariant (~node.failed(A) & ~node.failed(B)) ->
            (node.decision(A,V) = node.decision(B,V))
\end{lstlisting}
\end{mdframed}

Since the presented specification models deciding via a relation, it is theoretically possible for a node to decide on multiple values. To check against this possibility we demand every node may decide on at most one value.

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
invariant node.decision(N,V) -> (~exists O . node.decision(N,O) & O~=V)
\end{lstlisting}
\end{mdframed}

\subsection{Validity}
\textit{Validity} states: If all processes start with the same initial value v, then v is the only possible decision value.

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
invariant (exists N,M . node.val(N) ~= node.val(M)) |
          (system.decision_round ->
            (~node.failed(N2) -> node.decision(N2,node.val(N2))))
\end{lstlisting}
\end{mdframed}

\subsection{Termination}
\textit{Termination} states, that all non-faulty processes eventually decide.

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
invariant system.decision_round <->
            (forall N . (~node.failed(N) ->
                          (exists V . node.decision(N,V))))
\end{lstlisting}
\end{mdframed}
This invariant assumes that the system will eventually reach the decision round. However, truly verifying \textit{termination} would require checking that the system must reach the decision round, which means verifying  \textit{liveness}. Ivy theoretically allows \textit{liveness} checks by constructing a reduction of \textit{liveness} to \textit{safety} \cite{live} but this is out of the scope of this work.

\subsection{Invariants for Inductiveness}
If one were to run $ivy\_check$ on the program without specifying any
additional invariants, IVy finds that the \textit{agreement} invariant is not inductive,
and produces a counter example to induction (CTI). The CTI can be drawn in a GUI.

\noindent\includegraphics[width=\textwidth]{gui.png}

\noindent In the left hand section of the program we can see, that the system transitioned from state 0
to state 1 by executing \textit{round}. In the center IVy displays state 0, meaning the state
before \textit{round} was executed. The brown edges specify the relation $w$, the purple edges
show $val$.

State 0 shows, that no node has their initial value, which is modeled by the relation $val$,
in its $w$. The user must now realise, that this is an unreachable state, and exclude it by coming
up with an invariant.

The invariant excluding the unreachable state says, that the initial value of a node is always in its $w$:
\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
# initial value is in W
invariant node.w(N, node.val(N))
\end{lstlisting}
\end{mdframed}

The method for finding the remaining invariants is identical: Execute $ivy\_check$ $\rightarrow$ examine CTI $\rightarrow$ design invariant $\rightarrow$ execute $ivy\_check$. The following snippets presents the necessary invariants for induction annotated with comments.
\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
# the global default is the one the nodes know
invariant node.default(N) = node.def

# if a value is in a process' W, it must be initial value of
# some other process (no invented values)

invariant node.w(N, V) -> (exists M . node.val(M)=V)

# lemma 1:
invariant system.clean_round_occured ->
            (~node.failed(A) & ~node.failed(B)) ->
              (node.w(A, V) = node.w(B, V)))
\end{lstlisting}
\end{mdframed}

\subsection{Checking framework correctness}

Since any check on \textit{Floodset}'s correctness assumes that the \textit{framework} has been modeled correctly, it makes sense to include correctness conditions specifically aimed at the \textit{framework} in the form of invariants. These invariants are not necessary for induction. Removing them will not cause any of Ivy's other checks to fail. Their sole purpose is to give the user confidence that the \textit{framework} is specified correctly.

For example, we would like to check that $f < n$ at all times. This has nothing to do with \textit{Floodset}'s correctness and does not have to be specified for inductiveness. However, to the user it is useful to make sure that this condition is never broken. Line 4 checks $f < n$ by using the previously presented alternate encoding using an existential quantifier.

This snippet also shows some other simple checks of this kind. They are annotated with comments to facilitate understanding of their purpose.

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
####### system correctness checks #######

# f < n
invariant exists N . ~node.failed(N)

# 'after' a node has failed it cannot start working again
invariant node.failed_before_round(N) -> node.failed(N)

# 'after' a node has failed it will not send anything
invariant node.failed_before_round(N) -> ~node.incomming_message(M, N)

# If the decision round occured, a clean round must have occured
invariant system.decision_round -> system.clean_round_occured

\end{lstlisting}
\end{mdframed}

These invariants do not constitute a full-fledged proof of the framework being correctly modeled. For example, we have not proven that the \textit{framework} ever fails a node. This limitation will be discussed in detail in the next section.

\section{Evaluation}
How viable is IVy as a tool for algorithm designers proving correctness
of their work? The goal, when turning to a tool like IVy, is certainty of
correctness. However, due to a variety of reasons, absolute certainty is never achieved.
This section evaluates Ivy's usefulness pointing out strengths and limitations that Ivy users should keep in mind
when working with the system.

\subsection{Equivalence of specification and algorithm}
One can not trivially determine, that the specification in the IVy language is logically equivalent to the actual algorithm the user wishes to verify. Whether the algorithm to be verified exists in the user's mind, in the form of pseudo-code or fully implemented in a programming language, no guarantee can be given in regards to the correctness of the translation of the algorithm into the Ivy language. Some examples illustrating this difficulty will be given in the following paragraphs.

\subsubsection{Structural difference of Ivy and procedural languages}
The IVy language is structurally unlike classical procedural languages. This makes it inherently challenging to achieve a one-to-one translation from a classical distributed algorithm, that was specified in a procedural way, like \textit{Floodset}. An example of this structural difference is the relatively complicated quantifier-logic in assignments that update the global network state. Take as an example the first line of \textit{step2}:

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
node.w(N,V) := (node.w(N,V) |
               (~node.failed(N) &
                exists J . (node.incomming_message(N,J) &
                             node.message(J,V))));
\end{lstlisting}
\end{mdframed}

\noindent which models

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{gather*}
  \mathrm{let}\ X_j\ \mathrm{be\ the\ message\ from\ j,\ for\ each\ j\ from\ which\ a\ message\ arrives}\\
  W\ :=\ W \cup \bigcup_{j} X_j\\
\end{gather*}
\end{mdframed}

This comparison clearly shows the complex structural differences. While the pseudo-code is concerned only with state alteration of a single node, the Ivy language code simultaneously alters the state of all nodes. It uses an existential quantifier nested within a term. Its logic touches on multiple layers of abstraction as it mixes system and node concerns. It considers node failure, message reception and node state alteration.

As these two lines are so different, equivalence is certainly not obvious to a user. Proving equivalence of pseudo-code and Ivy language specification would certainly be a non-trivial proof exercise that certainly trumps manually proving \textit{Floodset}'s correctness in difficulty.

\subsubsection{Lack of modularity}
Furthermore, it has already been shown in section \textbf{IV. i.1} that the lack of easy iteration over types makes it difficult to achieve modularity. The lack of which introduces additional uncertainty about correct modelling, especially in distributed systems.


\subsection{Accidental invalidation of legal state configurations with \textit{assume}}
$assume$ statements may silently invalidate state configurations. They therefore pose a threat as they
may allow false-positive Ivy checks.
To give a practical example, the author of this paper originally modeled the line

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
node.w(N,V) := (node.w(N,V) |
               (~node.failed(N) &
                exists J . (node.incomming_message(N,J) &
                             node.message(J,V))));
\end{lstlisting}
\end{mdframed}

\noindent as

\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
node.tmp_w(A,V) := node.w(A V);
node.w(A,V) := *;
assume node.w(A,V) <-> (node.tmp_w(A,V) |
                        ((node.incomming_message(A,J) &
                          node.message(J,V))));
\end{lstlisting}
\end{mdframed}
The second snippet misses an existential quantifier on line 4, and therefore specifies behaviour that is unlike that of \textit{Floodset}.  The author did not discover that this $assume$ is bogus and excludes valid system states from being verified. The error only became apparent when it was discovered that correctness could be proven in the absence of an invariant that should have been absolutely necessary for induction.


\subsection{Miss-specification of system context}
As has been pointed out, it is not just the algorithm that must be correctly specified. The underlying \textit{framework} is equally important to get right. In the presented specification it is possible to remove the \textit{simulate\_failure} action and still receive a positive check from the IVy system. This is unsurprising, as we do not have any mechanism in place verifying that the system allows nodes to fail. More subtly, a user may incorrectly simulate partial message delivery of failing nodes, however all checks would still pass.

In general, the user is left with the question ``does my \textit{framework}-specification correctly allow for X to happen''.  Users may therefore want to verify, that their specification allows a certain state to occur. In regard to Lynch's \textit{framework} the user may wish to check that a node can fail during message delivery, resulting in partial message delivery.

One may use the following approach to verify that a particular system state is reachable:
\begin{enumerate}
  \item Construct a formula, $\gamma$, describing the system state in question.
  \item Negate the formula, $\neg\gamma$.
  \item Add \textit{assert} $\neg\gamma$ to an appropriate location in the specification.
  \item Check that the assertion fails.
  \item Remove the assertion.
\end{enumerate}

\noindent For example, one may insert
\begin{mdframed}[nobreak=true, backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=15, innertopmargin=15,innerbottommargin=15, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}
assert ~(exists N . node.failed(N) &
        (exists J . ~incoming_message(J,N) &
          exists K . incomming_message(K,N) & J~=N & K~=J & N~=K))
\end{lstlisting}
\end{mdframed}
after the \textit{simulate\_failure} action. The negated part, $\gamma$, specifies that there exists a node $N$, that failed and failed to deliver a message to $J$ while successfully delivering a message to $K$, with $N,J,K$ distinct. By negating $\gamma$, we force Ivy to construct a counterexample such that $\gamma$ is satisfied. If IVy does not find a counterexample to this assertion, it means that $\gamma$ cannot occur. In this particular case, that would mean the specification does not allow partial message delivery. The specification would therefore be erroneous. One has to finally remove the failing assertion to allow Ivy to prove induction again.

In light of this, it would be beneficial to have a built in mechanism to verify the possibility of certain states to occur. In this case, it would allow one to verify, that the modeled system allows for the possibility of a node to fail such that it only sends messages to a subset of processes, as part of the final proof.

Of course this approach would not constitute a proof of correct \textit{framework}-specification. It solely acts as a form of test.

\subsection{Necessity of deep understanding}
It has become apparent, that successful verification with IVy is not possible without deep knowledge about how the algorithm functions. Ivy is not a ``translate and go'' solution.
Evidence of this include the complex invariant that requires knowledge about \textit{Lemma 1} or the alternative encoding for $f<n$ and the decision condition $if\ rounds = f+1$ that had to be discovered.

\subsection{Algorithm failure in theory and practice}
As a user it is important to understand that Ivy's goal is to verify algorithmic correctness on a high level. It does not concern itself with implementation details. However, a variety of bugs and exploits do not stem from logically unsound algorithmic foundations but implementation errors. A wonderful example is the Heartbleed exploit in OpenSSL. It would have been no help to verify the Heartbeat protocol in IVy before implementing it in C, since the error was in an implementation detail allowing a buffer underflow. The Ivy user must realise, that the implementation of the algorithm must be tested through unit testing and/or bounded model checkers, despite successful verification in IVy.

\subsection{Time of specification}
Unfortunately the author missed the opportunity to scientifically record the time commitment of verifying \textit{Floodset} in Ivy. He estimates the time from starting to learn Ivy to successfully proving \textit{Floodset} at around 150 hours. In the case of \textit{Floodset} manual proving would have certainly been significantly faster. Drawing a general conclusion about practicability of Ivy is not possible from this data.

For future work, it may be interesting to study whether specification in Ivy gets easier or harder than manual proving as algorithmic complexity increases.


\subsection{User friendliness}
Despite these limitations, IVy trumps similar tools in user friendliness by upping interactivity. \cite{ivy}
IVy's counterexample to induction (CTI) viewer is remarkable, consistently showing truly minimal
state configurations that allow the user to quickly grasp the problem. The GUI also allows stepping
through individual lines and their effect on the state.


Therefore, if a user is capable of navigating the limitations with care, IVy is absolutely adequate for proving the logical soundness of an algorithm.



\section{Conclusion}
This paper has presented the Ivy system and important Ivy language features. It classified IVy
as part of a three step process of algorithm verification.
It explained that its usage requires a readiness to let go of procedural programming paradigms
in favor of the logic oriented language. It gave an explanation of induction and inductive invariants,
explaining what they are, how they are used by IVy to prove correctness and how they can be found.
It presented some of the systems capabilities to verify distributed algorithms by example.

It pointed out some limitations. One being that it is hard to know an algorithm was correctly specified in IVy. This is due to
the lack of easy type iteration, which leads to complicated global assignments and a non-modular structure that is far off
the original algorithm's.
The paper suggested a mechanism to verify the possibility of a state to occur, to alleviate this uncertainty.
Another limitation that was found, is the difference between a logically sound algorithm and a correctly implemented one, and how IVy can only verify the former.
It was stressed that successful verification of an algorithm that is not thoroughly understood by the user is unlikely.

It highlighted the systems strengths to be user friendliness, interactivity and a powerful logic based language that allows for
modeling of complex system state transitions in simple one-liners.

It concludes that IVy's user friendliness in presenting CTIs - so long as the user is vary of the presented limitations - enables
finding inductive invariants for proving logical soundness of an algorithm relatively easily.



%----------------------------------------------------------------------------------------
%	REFERENCE LIST
%----------------------------------------------------------------------------------------
\begin{thebibliography}{99}
    \bibitem{limits} K. Apt, D. Kozen ``Limits of Automatic Verification of Finite-State Concurrent Systems'', 1986, Available \textit{http://www.cs.cornell.edu/~kozen/Papers/LimitsForAutomatic.pdf}
    \bibitem{ivy} O. Padon, K. McMillan, A. Panda, M. Safiv, S. Shoham, ``Ivy: Safety Verification by Interactive Generalization'', Available \textit{https://www.cs.tau.ac.il/~odedp/ivy.pdf}
    \bibitem{live} O. Padon, J. Hönicke, G. Losa, A. Podelski, M. Sagiv, S. Shoham, ``Reducing Liveness to Safety in First-Order Logic'', Available \textit{https://www.cs.tau.ac.il/~odedp/reducing-liveness-to-safety-in-first-order-logic/}
    \bibitem{refLanguageDoc} ``The IVy language'',  \textit{http://microsoft.github.io/ivy/language.html} [Accessed: 5.06.18], 2017
    \bibitem{invariants} ``Invariants'',  \textit{http://microsoft.github.io/ivy/examples/client\_server\_example.html} [Accessed: 5.06.18], 2017
    \bibitem{decid} ``Decidability'',  \textit{http://microsoft.github.io/ivy/decidability.html} [Accessed: 5.06.18], 2017
    \bibitem{refNancy} N. Lynch, ``Distributed algorithms'', 1996, San Francisco: Morgan Kaufmann Publishers
    \bibitem{github} C. Claus, ``BA'', \textit{https://github.com/calvinclaus/ba}, 2018

\end{thebibliography}

%----------------------------------------------------------------------------------------

\end{document}
