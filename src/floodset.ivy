#lang ivy1.7

include order

type i
interpret i -> int

type value

type t
object node = {

  #graph/system related
  relation edge(A:t, B:t) function val(X:t) : value
  function default(X: t) : value
  individual def : value
  relation failed(A:t)
  relation failed_before_round(A:t)
  relation failed_during_round(A:t)
  relation tmp_failed(A:t)

  #state
  relation w(SELF:t, V:value)
  relation tmp_w(SELF:t, V:value)
  function rounds(SELF:t) : i
  relation decision(SELF:t, VALUE:value)

  #communication
  relation message(N:t, V:value)
  relation incomming_message(SELF:t, OTHER:t)
  relation incomming_message_mock(SELF:t, OTHER:t)

  after init {
    def := *;
    default(N) := def;
    rounds(N) := 0;
    w(N, V) := V=node.val(N);
    incomming_message(A, B) := false;
    decision(N, V) := false;

    ensure(rounds(N)=0);
    ensure forall N . (exists V:value . w(N, V) & ~exists O . w(N, O) & O ~= V);
  }


}

object system = {
  individual rounds:i
  individual decision_round:bool
  individual clean_round_occured:bool


  after init {
    rounds := 0;
    clean_round_occured := false;
    decision_round := false;
    node.failed_before_round(N) := false;
    node.failed(N) := false;

  }

  action round = {
    assume ~node.decision(N,V);
    assert ~decision_round;
    node.failed_before_round(N) := node.failed(N);
    call step1_without_iter;
    call fail_nodes_during_step_1;
    clean_round_occured := (clean_round_occured | (forall N . ~node.failed_during_round(N)));
    if clean_round_occured {
      decision_round := *;
    };
    call step2_without_iter;
    rounds := rounds+1;
  }

  action step1_without_iter = {
    node.message(A, M) := node.w(A, M);
    node.incomming_message(O, A) := ~node.failed(A);
  }

  action fail_nodes_during_step_1 = {
    node.failed_during_round(N) := *;
    assume node.failed_during_round(N) -> ~node.failed(N);
    node.incomming_message_mock(O, F) := *;
    node.incomming_message(O, F) := node.incomming_message(O,F) if ~node.failed_during_round(F) else node.incomming_message_mock(O, F);
    node.failed(N) := (node.failed(N) | node.failed_during_round(N));
    ensure node.failed_before_round(N) -> node.failed(N);
    assume exists N . ~node.failed(N);
  }

  action step2_without_iter = {
    node.rounds(A) := node.rounds(A)+1;
    node.tmp_w(A,V) := node.w(A, V);
    node.w(A, V) := *;
    assume (node.tmp_w(A, V) | ((node.incomming_message(A, J) & node.message(J, V)))) <-> node.w(A, V);


    if decision_round {
      node.decision(A, V) := node.w(A, V)                if (exists V:value . (node.w(A, V) & ~exists O . node.w(A, O) & O ~= V)) else node.decision(A, V);
      node.decision(A, node.default(A)) := (exists V:value . (node.w(A, V) & exists O . node.w(A, O) & O ~= V)) | (node.decision(A, node.default(A)));
    };

    node.incomming_message(A, B) := false;
    node.message(A, V) := false;
  }

}

export system.round

axiom exists N : t, M : t, O : t. N ~= M & N ~= O & M ~= O


####### system invariants #######

# only a number of nodes < f can fail ->  specified with assume
invariant exists N . ~node.failed(N)

# 'after' a node has failed it will not send anything
invariant node.failed_before_round(N) -> node.failed(N)
invariant node.failed_before_round(N) -> ~node.incomming_message(M, N)

# If the decision round occured, a clean round must have occured
invariant system.decision_round -> system.clean_round_occured

####### system invariants end #######





####### correctness conditions #######

# Agreement: No two processes decide on different values.
invariant node.decision(N, V) -> (~exists O . node.decision(N, O) & O~=V) # every node decides on at most one value
invariant system.decision_round -> ((~node.failed(A) & ~node.failed(B)) -> (node.decision(A, V) = node.decision(B, V)))

# Validity: If all processes start with the same initial value v, then v is the only possible decision value
invariant (exists N,M . node.val(N) ~= node.val(M)) | (system.decision_round -> node.decision(N2, node.val(N2)))

# Termination: All nonfaulty processes eventually decide.
invariant system.decision_round <-> (forall N . (~node.failed(N) -> (exists V . node.decision(N,V))))

####### correctness conditions end #######




####### invariants necessary for induction #######

invariant node.w(N, node.val(N))
invariant system.rounds >= 0
invariant node.rounds(A) = system.rounds
invariant (system.rounds = 0) -> (forall N . (exists V:value . node.w(N, V) & ~exists O . node.w(N, O) & O ~= V))
invariant (system.rounds = 0) -> (forall N,V . ~node.decision(N,V))
invariant node.default(N) = node.def
invariant node.w(N, V) -> (exists M . node.val(M)=V)
# lemma 1:
invariant system.clean_round_occured -> ((~node.failed(A) & ~node.failed(B)) -> (node.w(A, V) = node.w(B, V)))



####### invariants necessary for induction end #######
